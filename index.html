<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spine Viewer</title>
  <style>
    :root {
      --bg-dark: hsl(336 0% 1%);
      --bg: hsl(330 0% 4%);
      --bg-light: hsl(0 0% 9%);
      --text: hsl(0 0% 95%);
      --text-muted: hsl(300 0% 69%);
      --highlight: hsl(330 0% 39%);
      --border: hsl(0 0% 28%);
      --border-muted: hsl(300 0% 18%);
      --primary: hsl(50 43% 58%);
      --secondary: hsl(233 73% 79%);
      --danger: hsl(9 26% 64%);
      --warning: hsl(52 19% 57%);
      --success: hsl(146 17% 59%);
      --info: hsl(217 28% 65%);
      --bg-color: var(--bg-dark);
      --bg-elev-1: var(--bg);
      --bg-elev-2: var(--bg-light);
      --bg-elev-3: var(--highlight);
      --panel-border: var(--border);
      --text-color: var(--text);
      --text-dim: var(--text-muted);
      --accent-hsl: var(--primary);
      --accent-h: 50;
      --accent-s: 43%;
      --accent-l: 58%;
      --accent: hsl(var(--accent-h) var(--accent-s) var(--accent-l));
      --accent-strong: hsl(var(--accent-h) var(--accent-s) calc(var(--accent-l) + 8%));
      --accent-soft: hsl(var(--accent-h) calc(var(--accent-s) - 25%) calc(var(--accent-l) - 18%));
      --focus-ring: hsl(var(--accent-h) var(--accent-s) var(--accent-l) / 0.45);
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --transition: 0.18s cubic-bezier(.4, .15, .2, 1);
      --shadow-sm: 0 2px 4px -1px rgba(0, 0, 0, .5), 0 1px 2px rgba(0, 0, 0, .3);
      --shadow-md: 0 4px 12px -2px rgba(0, 0, 0, .55), 0 2px 4px rgba(0, 0, 0, .4);
    }

    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(180deg, var(--bg-dark), var(--bg));
      color: var(--text-color);
      -webkit-font-smoothing: antialiased;
    }

    .container {
      max-width: 90vw;
      margin: 0 auto;
    }

    .demo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .demo-card {
      background: var(--bg-elev-2);
      border-radius: var(--radius-lg);
      padding: 20px 22px 26px;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(4px);
    }

    spine-viewer {
      width: 100%;
      height: 60vh;
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-md);
      display: block;
      margin: 10px 0;
      background: radial-gradient(circle at 50% 45%, var(--bg) 0%, var(--bg-dark) 75%);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02), 0 6px 18px -6px rgba(0, 0, 0, 0.6);
      position: relative;
    }

    /* Drag & Drop highlight */
    spine-viewer.drag-over {
      outline: 3px dashed var(--accent);
      outline-offset: -3px;
      filter: brightness(1.1);
    }

    spine-viewer.drag-over::after {
      content: '放開滑鼠以載入檔案 ( .skel / .json + .atlas + image )';
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, .55);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
      letter-spacing: .5px;
      text-align: center;
      padding: 0 30px;
      backdrop-filter: blur(2px) brightness(1.2);
      pointer-events: none;
      text-shadow: 0 2px 4px rgba(0, 0, 0, .6);
      animation: dropPulse 0.9s ease-in-out infinite alternate;
    }

    @keyframes dropPulse {
      from {
        transform: scale(.985);
      }

      to {
        transform: scale(1.01);
      }
    }

    h1 {
      text-align: center;
      color: var(--text-color);
      margin-bottom: 30px;
      font-weight: 600;
      letter-spacing: .5px;
    }

    .controls {
      margin-top: 10px;
    }

    .controls button {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      border: 1px solid var(--border);
      padding: 8px 16px;
      border-radius: var(--radius-sm);
      margin-right: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .3px;
      position: relative;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, .6), 0 1px 2px rgba(0, 0, 0, .4);
      transition: var(--transition);
    }

    .controls button:hover {
      filter: brightness(1.06);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px -2px rgba(0, 0, 0, .7), 0 2px 4px rgba(0, 0, 0, .55);
    }

    .controls button:active {
      transform: translateY(0);
    }

    .controls input[type="url"],
    .controls select {
      background: var(--bg-elev-1);
      padding: 10px 12px;
      border: 1px solid var(--border-muted);
      border-radius: var(--radius-md);
      font-size: 14px;
      color: var(--text-color);
      transition: var(--transition);
      margin-right: 10px;
    }

    .controls input[type="url"]:focus,
    .controls select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--focus-ring);
    }

    #upload-status {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: var(--radius-md);
      font-size: 13px;
      background: var(--bg-elev-1);
      border: 1px solid var(--border-muted);
      color: var(--text-dim);
      line-height: 1.4;
      letter-spacing: .3px;
    }

    #animation-list {
      margin-top: 16px;
      background: var(--bg-elev-1);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 14px 16px 18px;
      color: var(--text-color);
      box-shadow: var(--shadow-sm);
    }

    #animation-list h4 {
      margin: 0 0 10px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .6px;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .anim-scroll {
      max-height: 240px;
      overflow-y: auto;
      padding-right: 4px;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) transparent;
    }

    .anim-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .anim-scroll::-webkit-scrollbar-track {
      background: #1a1f25;
      border-radius: 4px;
    }

    .anim-scroll::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, var(--accent), var(--accent-strong));
      border-radius: 4px;
    }

    .anim-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 8px;
    }

    .anim-btn {
      width: 100%;
      background: var(--bg-elev-2);
      color: var(--text-color);
      border: 1px solid var(--border-muted);
      border-radius: var(--radius-md);
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      line-height: 1.2;
      letter-spacing: .4px;
      transition: var(--transition);
      position: relative;
      font-weight: 500;
      text-align: left;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .anim-btn:hover {
      background: var(--bg-elev-3);
      border-color: var(--border);
      transform: translateY(-2px);
      box-shadow: 0 4px 10px -2px rgba(0, 0, 0, .6);
    }

    .anim-btn:active {
      transform: translateY(0);
    }

    .anim-btn.active {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent), 0 6px 16px -4px rgba(0, 0, 0, .65);
      font-weight: 600;
    }

    .anim-empty {
      font-size: 13px;
      opacity: .65;
      padding: 4px 2px;
    }


    #skin-list {
      margin-top: 16px;
      background: var(--bg-elev-1);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 14px 16px 18px;
      color: var(--text-color);
      box-shadow: var(--shadow-sm);
    }

    #skin-list h4 {
      margin: 0 0 10px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .6px;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .skin-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 8px;
    }

    .skin-btn {
      width: 100%;
      background: var(--bg-elev-2);
      color: var(--text-color);
      border: 1px solid var(--border-muted);
      border-radius: var(--radius-md);
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      line-height: 1.2;
      letter-spacing: .4px;
      transition: var(--transition);
      position: relative;
      font-weight: 500;
      text-align: left;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .skin-btn:hover {
      background: var(--bg-elev-3);
      border-color: var(--border);
      transform: translateY(-2px);
      box-shadow: 0 4px 10px -2px rgba(0, 0, 0, .6);
    }

    .skin-btn:active {
      transform: translateY(0);
    }

    .skin-btn.active {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent), 0 6px 16px -4px rgba(0, 0, 0, .65);
      font-weight: 600;
    }

    /* Animation Sequence Section */
    #animation-sequence-section {
      margin-top: 16px;
      background: var(--bg-elev-1);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 14px 16px 18px;
      color: var(--text-color);
      box-shadow: var(--shadow-sm);
    }

    #animation-sequence-section h4 {
      margin: 0 0 10px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .6px;
      text-transform: uppercase;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    #animation-sequence-section .sequence-controls {
      display: flex;
      gap: 8px;
    }

    #animation-sequence-section .sequence-controls button {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 600;
      font-size: 11px;
      letter-spacing: .3px;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, .6);
      transition: var(--transition);
    }

    #animation-sequence-section .sequence-controls button:hover {
      filter: brightness(1.06);
      transform: translateY(-1px);
    }

    #animation-sequence-section .sequence-controls button.secondary {
      background: var(--bg-elev-3);
      color: var(--text-color);
    }

    #sequence-drop-zone {
      min-height: 80px;
      border: 2px dashed var(--border-muted);
      border-radius: var(--radius-md);
      padding: 12px;
      margin-top: 10px;
      background: var(--bg-elev-2);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
      align-content: flex-start;
      transition: var(--transition);
    }

    #sequence-drop-zone.drag-over {
      border-color: var(--accent);
      background: var(--bg-elev-3);
      border-style: solid;
    }

    #sequence-drop-zone.empty {
      justify-content: center;
      align-items: center;
    }

    #sequence-drop-zone .placeholder {
      color: var(--text-dim);
      font-size: 13px;
      opacity: .65;
      text-align: center;
      width: 100%;
    }

    .sequence-item {
      background: var(--bg-elev-3);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 8px 12px;
      font-size: 12px;
      color: var(--text-color);
      cursor: grab;
      user-select: none;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
      transition: var(--transition);
      overflow: hidden;
    }

    .sequence-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    }

    .sequence-item:hover {
      background: var(--highlight);
      transform: translateY(-2px);
      box-shadow: 0 4px 10px -2px rgba(0, 0, 0, .6);
    }

    .sequence-item.dragging {
      opacity: 0.4;
      cursor: grabbing;
      transform: scale(0.95);
      box-shadow: 0 8px 20px -4px rgba(0, 0, 0, .8);
    }

    .sequence-item.drag-over {
      border-top: 3px solid var(--accent) !important;
      margin-top: 2px;
    }

    .sequence-item.playing {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent), 0 6px 16px -4px rgba(0, 0, 0, .65);
      font-weight: 600;
    }

    .sequence-item:active {
      cursor: grabbing;
    }

    .sequence-item .remove-btn {
      background: rgba(255, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: var(--transition);
    }

    .sequence-item .remove-btn:hover {
      background: rgba(255, 0, 0, 0.9);
      transform: scale(1.1);
    }

    .sequence-item .drag-handle {
      cursor: grab;
      opacity: 0.5;
      font-size: 14px;
    }

    .sequence-item .sequence-number {
      font-weight: 600;
      opacity: 0.7;
      min-width: 20px;
    }

    .sequence-item-content {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
    }

    .sequence-item-name {
      flex: 1;
    }

    /* Progress bar for sequence items */
    .sequence-progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    .sequence-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-strong));
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s linear;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
    }

    .sequence-item.playing .sequence-progress-fill {
      background: linear-gradient(90deg, #1c1405, #2a2010);
    }

    /* Multi-Track Styles */
    #multi-track-section {
      margin-top: 16px;
    }

    .multi-track-toggle {
      margin-bottom: 12px;
    }

    #enable-multi-track-btn {
      background: linear-gradient(135deg, var(--secondary), hsl(233 73% 85%));
      color: #0a0c14;
      border: 1px solid var(--border);
      padding: 8px 16px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
      letter-spacing: .4px;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, .6);
      transition: var(--transition);
    }

    #enable-multi-track-btn:hover {
      filter: brightness(1.08);
      transform: translateY(-1px);
    }

    #enable-multi-track-btn.active {
      background: linear-gradient(135deg, var(--danger), hsl(9 26% 70%));
      color: #1c0a0a;
    }

    .multi-track-container {
      background: var(--bg-elev-1);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 14px 16px 18px;
      color: var(--text-color);
      box-shadow: var(--shadow-sm);
    }

    .multi-track-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 12px;
    }

    .multi-track-header h4 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .6px;
      text-transform: uppercase;
      color: var(--text-dim);
      flex-shrink: 0;
    }

    .playback-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-grow: 1;
    }

    .playback-btn {
      padding: 6px 12px;
      background: var(--bg-elev-2);
      color: var(--text-color);
      border: 1px solid var(--border);
      border-radius: 5px;
      cursor: pointer;
      transition: var(--transition);
      font-size: 14px;
      font-weight: 600;
      min-width: 40px;
    }

    .playback-btn:hover:not(:disabled) {
      background: var(--bg-elev-3);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .playback-btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .playback-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .playback-btn.play-btn:not(:disabled) {
      background: linear-gradient(135deg, #2d7a3e, #3fa055);
      border-color: #3fa055;
      color: white;
    }

    .playback-btn.stop-btn:not(:disabled) {
      background: linear-gradient(135deg, #8b3a3a, #b84848);
      border-color: #b84848;
      color: white;
    }

    .playback-time {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: var(--text-dim);
      padding: 0 8px;
      min-width: 85px;
      text-align: center;
    }

    .add-track-btn {
      background: linear-gradient(135deg, var(--success), hsl(146 17% 65%));
      color: #0a140c;
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 600;
      font-size: 11px;
      letter-spacing: .3px;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, .6);
      transition: var(--transition);
    }

    .add-track-btn:hover {
      filter: brightness(1.08);
      transform: translateY(-1px);
    }

    .tracks-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .track {
      background: var(--bg-elev-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 10px;
      transition: var(--transition);
    }

    .track:hover {
      border-color: var(--accent-soft);
    }

    .track-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-muted);
    }

    .track-name {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
      letter-spacing: .4px;
      flex-grow: 1;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: var(--transition);
    }

    .track-name:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-color);
    }

    .track-name-input {
      flex-grow: 1;
      background: var(--bg-elev-3);
      color: var(--text-color);
      border: 1px solid var(--accent);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .4px;
      outline: none;
      box-shadow: 0 0 0 2px var(--focus-ring);
    }

    .track-name-input::placeholder {
      color: var(--text-dim);
      opacity: 0.6;
    }

    .track-header.editing {
      background: rgba(255, 255, 255, 0.02);
    }

    .delete-track-btn {
      background: transparent;
      color: var(--danger);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 4px 10px;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      transition: var(--transition);
    }

    .delete-track-btn:hover {
      background: var(--danger);
      color: var(--bg-dark);
      transform: scale(1.1);
    }

    .track-slots {
      min-height: 60px;
      border: 2px dashed var(--border-muted);
      border-radius: var(--radius-sm);
      padding: 8px;
      background: var(--bg-elev-1);
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      transition: var(--transition);
    }

    .track-slots.drag-over {
      border-color: var(--accent);
      background: var(--bg-elev-3);
      border-style: solid;
    }

    .track-slots .placeholder {
      width: 100%;
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
      opacity: .6;
      padding: 12px 0;
    }

    .slot {
      background: var(--bg-elev-3);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 6px 10px;
      font-size: 11px;
      color: var(--text-color);
      min-width: 80px;
      text-align: center;
      transition: var(--transition);
    }

    .slot.empty {
      border-style: dashed;
      opacity: .5;
      color: var(--text-dim);
    }

    .slot.occupied {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      font-weight: 600;
      position: relative;
      cursor: grab;
    }

    .slot.occupied:active {
      cursor: grabbing;
    }

    .slot.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }

    .slot.drag-over {
      border-color: var(--accent);
      border-style: solid;
      border-width: 2px;
      box-shadow: 0 0 8px var(--focus-ring);
    }

    .slot-content {
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .slot-remove-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(0, 0, 0, 0.4);
      color: var(--text-color);
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: var(--transition);
    }

    .slot.occupied:hover .slot-remove-btn {
      opacity: 1;
    }

    .slot-remove-btn:hover {
      background: var(--danger);
      color: white;
    }

    .slot.playing {
      border-color: var(--accent);
      border-style: solid;
      box-shadow: 0 0 12px var(--focus-ring);
      animation: slot-pulse 1s ease-in-out infinite;
    }

    @keyframes slot-pulse {

      0%,
      100% {
        box-shadow: 0 0 12px var(--focus-ring);
      }

      50% {
        box-shadow: 0 0 20px var(--accent);
      }
    }

    /* Color picker modal styles */
    .color-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      z-index: 10000;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }

    .color-picker-modal.show {
      display: flex;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .color-picker-card {
      background: var(--bg-elev-2);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-lg);
      padding: 24px 28px;
      box-shadow: var(--shadow-md), 0 12px 32px -8px rgba(0, 0, 0, 0.7);
      min-width: 320px;
      animation: slideUp 0.25s cubic-bezier(.4, .15, .2, 1);
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.96);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .color-picker-card h3 {
      margin: 0 0 18px;
      color: var(--text-color);
      font-size: 18px;
      font-weight: 600;
      letter-spacing: .5px;
    }

    .custom-color-picker {
      margin-bottom: 20px;
    }

    /* Saturation/Brightness Selector */
    .color-selector {
      width: 100%;
      height: 200px;
      border-radius: var(--radius-md);
      position: relative;
      cursor: crosshair;
      margin-bottom: 16px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1), var(--shadow-sm);
      background: linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, transparent);
    }

    .color-selector-thumb {
      position: absolute;
      width: 16px;
      height: 16px;
      border: 3px solid #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5), 0 2px 6px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
    }

    .color-selector-thumb.active {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* Hue Slider */
    .hue-slider-wrapper {
      margin-bottom: 16px;
    }

    .hue-slider {
      width: 100%;
      height: 20px;
      border-radius: 10px;
      position: relative;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1), var(--shadow-sm);
      background: linear-gradient(to right,
          #ff0000 0%, #ffff00 17%, #00ff00 33%,
          #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
    }

    .hue-slider-thumb {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 3px solid #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5), 0 2px 6px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
    }

    .hue-slider-thumb.active {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* Color Preview & Hex Input */
    .color-preview-wrapper {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .color-preview {
      width: 60px;
      height: 48px;
      border: 2px solid var(--border);
      border-radius: var(--radius-md);
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), var(--shadow-sm);
      transition: var(--transition);
    }

    .color-hex-input {
      flex: 1;
      background: var(--bg-elev-1);
      border: 1px solid var(--border-muted);
      border-radius: var(--radius-md);
      padding: 12px 14px;
      color: var(--text-color);
      font-size: 14px;
      font-family: 'Courier New', monospace;
      letter-spacing: .5px;
      transition: var(--transition);
      text-transform: uppercase;
    }

    .color-hex-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--focus-ring);
    }

    /* Preset Colors */
    .preset-colors {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 8px;
      margin-bottom: 20px;
    }

    .preset-color {
      width: 100%;
      aspect-ratio: 1;
      border: 2px solid var(--border-muted);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .preset-color:hover {
      border-color: var(--accent);
      transform: scale(1.1);
      box-shadow: 0 0 0 2px var(--focus-ring), inset 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .preset-color.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--focus-ring), inset 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .preset-color.default-preset {
      position: relative;
    }

    .preset-color.default-preset::after {
      content: '';
      position: absolute;
      bottom: -2px;
      right: -2px;
      width: 8px;
      height: 8px;
      background: var(--accent);
      border: 1.5px solid var(--bg-elev-2);
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    }

    .color-picker-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .color-picker-buttons button {
      background: linear-gradient(135deg, var(--accent-soft), var(--accent));
      color: #1c1405;
      border: 1px solid var(--border);
      padding: 10px 20px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .3px;
      box-shadow: var(--shadow-sm);
      transition: var(--transition);
    }

    .color-picker-buttons button:hover {
      filter: brightness(1.06);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .color-picker-buttons button.cancel {
      background: var(--bg-elev-3);
      color: var(--text-color);
    }

    .color-picker-buttons button.cancel:hover {
      background: var(--highlight);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="demo-grid">
      <div class="demo-card">
        <spine-viewer id="spineViewer" animation-name="idle" src="./docs/spineboy/spineboy-pro.json"></spine-viewer>
        <div class="controls">
          <button type="button" onclick="document.getElementById('spine-file-input').click()">選擇檔案</button>
          <button id="toggle-skeleton-btn" onclick="toggleSkeletonDebug('spineViewer')">顯示骨架</button>
          <button id="change-bg-btn" onclick="openBgColorPicker('spineViewer')">背景顏色</button>
          <a id="upload-status">_(:3 」∠ )_</a>
          <div style="display:none;">
            <input type="url" id="spine-url" placeholder="留空白就好" />
            <button onclick="loadSpineFromUrl()">載入 Spine</button>
          </div>
          <input id="spine-file-input" type="file" style="display:none;" multiple accept=".skel,.json,.atlas,image/*"
            onchange="handleSpineFileSelection(event)" />
        </div>
        <div id='skin-list'></div>
        <div id="animation-list"></div>
        <div id="animation-sequence-section"></div>
      </div>
    </div>
  </div>

  <!-- Color Picker Modal -->
  <div id="color-picker-modal" class="color-picker-modal" onclick="closeBgColorPicker(event)">
    <div class="color-picker-card" onclick="event.stopPropagation()">
      <h3>選擇背景顏色</h3>

      <div class="custom-color-picker">
        <!-- Saturation/Brightness Selector -->
        <div id="color-selector" class="color-selector">
          <div id="color-selector-thumb" class="color-selector-thumb"></div>
        </div>

        <!-- Hue Slider -->
        <div class="hue-slider-wrapper">
          <div id="hue-slider" class="hue-slider">
            <div id="hue-slider-thumb" class="hue-slider-thumb"></div>
          </div>
        </div>

        <!-- Color Preview & Hex Input -->
        <div class="color-preview-wrapper">
          <div id="color-preview" class="color-preview"></div>
          <input type="text" id="bg-color-hex" class="color-hex-input" value="#2B2B2B" placeholder="#RRGGBB"
            maxlength="7">
        </div>

        <!-- Preset Colors -->
        <div class="preset-colors" id="preset-colors"></div>
      </div>

      <div class="color-picker-buttons">
        <button class="cancel" onclick="closeBgColorPicker()">取消</button>
        <button onclick="applyBgColor()">套用</button>
      </div>
    </div>
  </div>

  <!-- Demo bootstrap: imports src in dev, dist/CDN in production (see src/demo-entry.js) -->
  <script type="module" src="./src/spine-viewer.js"></script>
  <script>
    function autoListSpineData(viewerId, attempts = 0) {
      const maxAttempts = 50;
      const viewer = document.getElementById(viewerId);
      if (!viewer) return;
      try {
        const animations = viewer.getAnimations ? viewer.getAnimations() : [];
        if (animations && animations.length) {
          listSpineData(viewerId);
          return;
        }
      } catch (e) { } if (attempts < maxAttempts) {
        setTimeout(() => autoListSpineData(viewerId, attempts + 1), 100);
      }
    }

    function changeAnimation(viewerId, animationName) {
      const viewer = document.getElementById(viewerId);
      const currentAnimation = viewer.getCurrentAnimation ? viewer.getCurrentAnimation() : null;

      // Check if clicking the same animation that's currently playing
      if (currentAnimation === animationName && viewer.spine && viewer.spine.state) {
        const track = viewer.spine.state.tracks[0];

        // Toggle pause/resume
        if (track && track.timeScale !== undefined) {
          if (track.timeScale === 0) {
            // Resume animation
            track.timeScale = 1;
            console.log(`[Animation] Resumed: ${animationName}`);
          } else {
            // Pause animation
            track.timeScale = 0;
            console.log(`[Animation] Paused: ${animationName}`);
          }
        }
      } else {
        // Play new animation (and ensure it's not paused)
        viewer.setAnimation(animationName);
        if (viewer.spine && viewer.spine.state && viewer.spine.state.tracks[0]) {
          viewer.spine.state.tracks[0].timeScale = 1;
        }
      }

      listSpineData(viewerId);
    }

    function changeSkin(viewerId, skinName) {
      const viewer = document.getElementById(viewerId);
      viewer.setSkin(skinName);
      listSpineData(viewerId);
    }

    function listSpineData(viewerId) {
      const viewer = document.getElementById(viewerId);
      const skins = viewer.getSkins();
      const skinListElement = document.getElementById('skin-list');
      const animations = viewer.getAnimations();
      const animDetails = viewer.getAnimationsWithDetails ? viewer.getAnimationsWithDetails() : [];
      const listElement = document.getElementById('animation-list');
      const current = viewer.getCurrentAnimation ? viewer.getCurrentAnimation() : null;

      // Check if current animation is paused
      let isPaused = false;
      if (viewer.spine && viewer.spine.state && viewer.spine.state.tracks[0]) {
        isPaused = viewer.spine.state.tracks[0].timeScale === 0;
      }

      if (skins.length > 1) {
        console.log('Available skins:');
        console.log(skins);
        viewer.setDefaultSkin();
        const skinButtons = skins.map(skin => {
          try {
            const safe = skin.replace(/"/g, '&quot;');
            const isActiveSkin = viewer.getCurrentSkin() === skin;
            const activeCls = isActiveSkin ? 'active' : '';
            return `<button class="skin-btn ${activeCls}" onclick="changeSkin('${viewerId}', '${safe}')"
            title="${safe}">${skin}</button>`;
          } catch (e) {
            console.error('Error creating skin button for', skin, e);
            return `<button class="skin-btn ${activeCls}" title="${safe}">${skin}</button>`;
          }

        }).join('');
        skinListElement.innerHTML = `<h4>可用外觀</h4><div class="skin-list">${skinButtons}</div>`;
        skinListElement.style.display = 'block';
      } else {
        skinListElement.innerHTML = '';
        skinListElement.style.display = 'none';
      }

      // Debug: log animation details
      console.log('[Animation Details]', animDetails);

      if (animations.length > 0) {
        const buttons = animations.map((anim, index) => {
          const safe = anim.replace(/"/g, '&quot;');
          const isCurrentAnim = current === anim;
          const activeCls = isCurrentAnim ? 'active' : '';

          // Add paused indicator for current animation if paused
          const pauseIndicator = isCurrentAnim && isPaused ? ' ⏸' : '';

          // Get details for this animation
          const details = animDetails.find(d => d.name === anim);
          let layerInfo = '';
          if (details) {
            const parts = [];
            if (details.slotCount > 0) parts.push(`${details.slotCount} slot${details.slotCount > 1 ? 's' : ''}`);
            if (details.boneCount > 0) parts.push(`${details.boneCount} bone${details.boneCount > 1 ? 's' : ''}`);
            if (parts.length > 0) {
              layerInfo = `<div style="font-size: 10px; opacity: 0.7; margin-top: 2px;">${parts.join(', ')}</div>`;
            }
          }

          return `<li><button class="anim-btn ${activeCls}" draggable="true" ondragstart="handleAnimDragStart(event, '${safe}')" onclick="changeAnimation('${viewerId}', '${safe}')" title="${safe}">${anim}${pauseIndicator}${layerInfo}</button></li>`;
        }).join('');
        listElement.innerHTML = `<h4>可用動畫</h4><div class="anim-scroll"><ul class="anim-list">${buttons}</ul></div>`;
      } else {
        listElement.innerHTML = '<div class="anim-empty">暫無動畫資料</div>';
      }

      // Initialize animation sequence section
      initAnimationSequence(viewerId);

      // Show multi-track option
      showMultiTrackOption();
    }

    function loadSpineFromUrl() {
      const urlInput = document.getElementById('spine-url');
      const statusElement = document.getElementById('upload-status');
      const spineUrl = urlInput.value.trim();
      if (!spineUrl) {
        statusElement.className = 'status-error';
        statusElement.textContent = '請輸入 Spine 檔案路徑';
        return;
      }

      const validExtensions = ['.skel', '.json'];
      const hasValidExtension = validExtensions.some(ext => spineUrl.toLowerCase().includes(ext));
      if (!hasValidExtension) {
        statusElement.className = 'status-error';
        statusElement.textContent = '路徑應該指向 .skel 或 .json 格式的 Spine 檔案';
        return;
      }

      statusElement.className = 'status-info';
      statusElement.textContent = '正在載入 Spine 檔案...';
      const viewer = document.getElementById('spineViewer');
      try {
        viewer.renderSpine({ src: spineUrl });
        autoListSpineData('spineViewer');

        // Reapply saved background color after loading
        applySavedBgColor(viewer);

        statusElement.className = 'status-success';
        statusElement.textContent = 'Spine 檔案載入成功！';
      } catch (error) {
        statusElement.className = 'status-error';
        statusElement.textContent = `載入失敗: ${error.message}`;
        console.error('Spine 載入錯誤:', error);
      }
    }

    function selectCharacter() {
      const select = document.getElementById('character-select');
      const urlInput = document.getElementById('spine-url');
      const character = select.value;
      if (character) {
        urlInput.value = `./docs/${character}/${character}.skel`;
        loadSpineFromUrl();
      }
    }

    function toggleSkeletonDebug(viewerId) {
      const viewer = document.getElementById(viewerId);
      const btn = document.getElementById('toggle-skeleton-btn');
      if (!viewer) return;
      if (viewer.drawSkeleton) {
        viewer.disableSkeletonDebug();
        btn.textContent = '顯示骨架';
      } else {
        viewer.setSkeletonDebug(true);
        btn.textContent = '隱藏骨架';
      }
    }

    // Handle multi-file selection for Spine assets (.skel / .json / .atlas / images)
    function handleSpineFileSelection(e) {
      const input = e.target;
      const files = Array.from(input.files || []);
      console.log('[spine-viewer] Selected files:', files.map(f => f.name));
      // Call hook for future extension
      onSpineFilesSelected(files);
      // Allow selecting the same files again by clearing value
      input.value = '';
    }

    // Placeholder hook that can be customized later
    async function onSpineFilesSelected(files) {
      const skeletonFile = files.find(f => f.name.endsWith('.skel') || f.name.endsWith('.json'));
      if (!skeletonFile) {
        alert('請選擇包含 .skel 或 .json 檔案的 Spine 資料');
        return;
      }
      const skeletonFileExtString = skeletonFile.name.endsWith('.skel') ? '.skel' : '.json';

      const imageFile = files.find(f => f.name.endsWith('.png') || f.name.endsWith('.jpg') || f.name.endsWith('.jpeg'));
      if (!imageFile) {
        alert('請選擇包含圖片檔案（.png, .jpg, .jpeg）的 Spine 資料');
        return;
      }
      const imageFileExtString = imageFile.name.endsWith('.png') ? '.png' : (imageFile.name.endsWith('.jpg') ? '.jpg' : '.jpeg');

      const atlasFile = files.find(f => f.name.endsWith('.atlas'));
      if (!atlasFile) {
        alert('請選擇包含 .atlas 檔案的 Spine 資料');
        return;
      }

      const viewer = document.getElementById('spineViewer');
      if (!viewer) {
        alert('找不到 spine-viewer 元件');
        return;
      }

      const skeletonUrl = URL.createObjectURL(skeletonFile);
      const imageUrl = imageFile ? URL.createObjectURL(imageFile) : null;
      const atlasUrl = atlasFile ? URL.createObjectURL(atlasFile) : null;

      // convert files into base 64 string
      const skeletonBase64 = await fileToBase64(skeletonFile);
      const imageBase64 = imageFile ? await fileToBase64(imageFile) : null;
      const atlasBase64 = atlasFile ? await fileToBase64(atlasFile) : null;

      try {
        await viewer.renderSpine({
          src: {
            spineSkeleton: { src: skeletonBase64, format: skeletonFileExtString },
            spineImage: { name: imageFile.name, url: imageUrl, src: imageBase64, format: imageFileExtString },
            spineAtlas: { src: atlasBase64, format: '.atlas' },
          }
        });
        autoListSpineData('spineViewer');

        // Reapply saved background color after loading new spine
        applySavedBgColor(viewer);
      }
      catch (error) {
        alert(`載入 Spine 檔案失敗: ${error.message}`);
        console.error('Spine 載入錯誤:', error);
      }
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
      });
    }

    // Drag & Drop integration ----------------------------------------------
    function setupSpineDragAndDrop() {
      const dropZone = document.getElementById('spineViewer');
      if (!dropZone) return;

      const acceptableExt = /\.(skel|json|atlas|png|jpg|jpeg)$/i;

      function prevent(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      // Global prevent default so browser doesn't open file
      window.addEventListener('dragover', prevent);
      window.addEventListener('drop', e => {
        // Allow drop only if it's on our zone; otherwise just prevent navigation
        prevent(e);
      });

      ['dragenter', 'dragover'].forEach(evt => {
        dropZone.addEventListener(evt, e => {
          prevent(e);
          const items = Array.from(e.dataTransfer?.items || []);
          if (items.some(it => it.kind === 'file')) {
            dropZone.classList.add('drag-over');
          }
        });
      });

      dropZone.addEventListener('dragleave', e => {
        // Remove highlight only if leaving the element (relatedTarget null when leaving window)
        if (!dropZone.contains(e.relatedTarget)) {
          dropZone.classList.remove('drag-over');
        }
      });
      dropZone.addEventListener('dragend', () => dropZone.classList.remove('drag-over'));

      // Fallback: if mouse leaves window entirely
      window.addEventListener('dragleave', e => {
        if (e.clientX <= 0 || e.clientY <= 0 || e.clientX >= window.innerWidth || e.clientY >= window.innerHeight) {
          dropZone.classList.remove('drag-over');
        }
      });

      dropZone.addEventListener('drop', e => {
        prevent(e);
        dropZone.classList.remove('drag-over');
        const files = Array.from(e.dataTransfer?.files || []);
        if (!files.length) return;
        // Filter to acceptable extensions (optional: keep all and rely on handler)
        const filtered = files.filter(f => acceptableExt.test(f.name));
        const finalFiles = filtered.length ? filtered : files; // fallback if user dropped a zip etc.
        handleSpineFileSelection({ target: { files: finalFiles } });
      });
      console.log('[spine-viewer] Drag & Drop setup complete (improved)');
    }

    // Custom Color Picker Implementation
    let currentViewerId = null;
    let pickerState = {
      hue: 0,
      saturation: 0,
      brightness: 0,
      isDraggingSaturation: false,
      isDraggingHue: false
    };

    const presetColors = [
      '#000000', '#1a1a1a', '#2b2b2b', '#3d3d3d',
      '#595959', '#f0f0f0', '#d0d0d0', '#a0a0a0',
      '#590000', '#005900', '#000059', '#595900',
      '#590059', '#005959', '#594400', '#440059'
    ];

    function openBgColorPicker(viewerId) {
      currentViewerId = viewerId;
      const viewer = document.getElementById(viewerId);
      if (!viewer || !viewer.app) return;

      // Get current background color (should be the saved one)
      const currentBg = viewer.app.renderer.background.color;
      const hexColor = '#' + currentBg.toString(16).padStart(6, '0').toUpperCase();

      // Initialize picker with current color
      initColorPicker(hexColor);

      // Show modal
      const modal = document.getElementById('color-picker-modal');
      modal.classList.add('show');
    }

    function closeBgColorPicker(event) {
      if (!event || event.target.classList.contains('color-picker-modal')) {
        const modal = document.getElementById('color-picker-modal');
        modal.classList.remove('show');
        currentViewerId = null;
      }
    }

    function applyBgColor() {
      if (!currentViewerId) return;

      const viewer = document.getElementById(currentViewerId);
      if (!viewer || !viewer.app) return;

      const colorHex = document.getElementById('bg-color-hex').value;

      if (!/^#[0-9A-Fa-f]{6}$/i.test(colorHex)) {
        alert('請輸入有效的顏色代碼 (例如: #2B2B2B)');
        return;
      }

      const colorNumber = parseInt(colorHex.substring(1), 16);
      viewer.app.renderer.background.color = colorNumber;

      // Save to localStorage
      localStorage.setItem('spineViewerBgColor', colorHex);

      closeBgColorPicker();
    }

    function getSavedBgColor() {
      return localStorage.getItem('spineViewerBgColor') || '#2b2b2b';
    }

    function applySavedBgColor(viewer) {
      if (!viewer || !viewer.app) return;
      const savedColor = getSavedBgColor();
      const colorNumber = parseInt(savedColor.substring(1), 16);
      viewer.app.renderer.background.color = colorNumber;
    }

    function initColorPicker(hexColor) {
      // Convert hex to HSB
      const hsb = hexToHSB(hexColor);
      pickerState.hue = hsb.h;
      pickerState.saturation = hsb.s;
      pickerState.brightness = hsb.b;

      // Setup preset colors
      const presetContainer = document.getElementById('preset-colors');
      const defaultColor = '#2b2b2b';
      presetContainer.innerHTML = presetColors.map(color => {
        const isDefault = color.toLowerCase() === defaultColor.toLowerCase();
        const title = isDefault ? 'title="預設顏色"' : '';
        const defaultClass = isDefault ? ' default-preset' : '';
        return `<div class="preset-color${defaultClass}" style="background-color: ${color}" data-color="${color}" ${title}></div>`;
      }).join('');

      // Add preset color click handlers
      presetContainer.querySelectorAll('.preset-color').forEach(el => {
        el.addEventListener('click', () => {
          const color = el.dataset.color;
          const hsb = hexToHSB(color);
          pickerState.hue = hsb.h;
          pickerState.saturation = hsb.s;
          pickerState.brightness = hsb.b;
          updateColorPicker();
        });
      });      // Setup color selector
      const colorSelector = document.getElementById('color-selector');
      const colorSelectorThumb = document.getElementById('color-selector-thumb');

      colorSelector.addEventListener('mousedown', (e) => {
        pickerState.isDraggingSaturation = true;
        colorSelectorThumb.classList.add('active');
        updateSaturationBrightness(e);
      });

      // Setup hue slider
      const hueSlider = document.getElementById('hue-slider');
      const hueSliderThumb = document.getElementById('hue-slider-thumb');

      hueSlider.addEventListener('mousedown', (e) => {
        pickerState.isDraggingHue = true;
        hueSliderThumb.classList.add('active');
        updateHue(e);
      });

      // Global mouse handlers
      document.addEventListener('mousemove', (e) => {
        if (pickerState.isDraggingSaturation) {
          updateSaturationBrightness(e);
        } else if (pickerState.isDraggingHue) {
          updateHue(e);
        }
      });

      document.addEventListener('mouseup', () => {
        pickerState.isDraggingSaturation = false;
        pickerState.isDraggingHue = false;
        colorSelectorThumb.classList.remove('active');
        hueSliderThumb.classList.remove('active');
      });

      // Hex input handler
      const hexInput = document.getElementById('bg-color-hex');
      hexInput.addEventListener('input', (e) => {
        const value = e.target.value;
        if (/^#[0-9A-Fa-f]{6}$/i.test(value)) {
          const hsb = hexToHSB(value);
          pickerState.hue = hsb.h;
          pickerState.saturation = hsb.s;
          pickerState.brightness = hsb.b;
          updateColorPicker();
        }
      });

      updateColorPicker();
    }

    function updateSaturationBrightness(e) {
      const colorSelector = document.getElementById('color-selector');
      const rect = colorSelector.getBoundingClientRect();
      const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
      const y = Math.max(0, Math.min(e.clientY - rect.top, rect.height));

      pickerState.saturation = (x / rect.width) * 100;
      pickerState.brightness = (1 - (y / rect.height)) * 100;

      updateColorPicker();
    }

    function updateHue(e) {
      const hueSlider = document.getElementById('hue-slider');
      const rect = hueSlider.getBoundingClientRect();
      const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));

      pickerState.hue = (x / rect.width) * 360;

      updateColorPicker();
    }

    function updateColorPicker() {
      const { hue, saturation, brightness } = pickerState;

      // Update color selector background
      const colorSelector = document.getElementById('color-selector');
      const hueColor = hsbToHex(hue, 100, 100);
      colorSelector.style.background = `
        linear-gradient(to top, #000, transparent),
        linear-gradient(to right, #fff, ${hueColor})
      `;

      // Update saturation/brightness thumb position
      const colorSelectorThumb = document.getElementById('color-selector-thumb');
      colorSelectorThumb.style.left = `${saturation}%`;
      colorSelectorThumb.style.top = `${100 - brightness}%`;

      // Update hue slider thumb position
      const hueSliderThumb = document.getElementById('hue-slider-thumb');
      hueSliderThumb.style.left = `${(hue / 360) * 100}%`;

      // Update color preview and hex input
      const finalColor = hsbToHex(hue, saturation, brightness);
      const colorPreview = document.getElementById('color-preview');
      const hexInput = document.getElementById('bg-color-hex');

      colorPreview.style.backgroundColor = finalColor;
      hexInput.value = finalColor.toUpperCase();
    }

    // Color conversion utilities
    function hexToHSB(hex) {
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const delta = max - min;

      let h = 0;
      if (delta !== 0) {
        if (max === r) h = ((g - b) / delta + (g < b ? 6 : 0)) / 6;
        else if (max === g) h = ((b - r) / delta + 2) / 6;
        else h = ((r - g) / delta + 4) / 6;
      }

      const s = max === 0 ? 0 : (delta / max) * 100;
      const v = max * 100;

      return { h: h * 360, s, b: v };
    }

    function hsbToHex(h, s, b) {
      h = h / 360;
      s = s / 100;
      b = b / 100;

      const i = Math.floor(h * 6);
      const f = h * 6 - i;
      const p = b * (1 - s);
      const q = b * (1 - f * s);
      const t = b * (1 - (1 - f) * s);

      let r, g, bl;
      switch (i % 6) {
        case 0: r = b; g = t; bl = p; break;
        case 1: r = q; g = b; bl = p; break;
        case 2: r = p; g = b; bl = t; break;
        case 3: r = p; g = q; bl = b; break;
        case 4: r = t; g = p; bl = b; break;
        case 5: r = b; g = p; bl = q; break;
      }

      const toHex = (n) => {
        const hex = Math.round(n * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };

      return `#${toHex(r)}${toHex(g)}${toHex(bl)}`;
    }

    // Animation Sequence Controller
    let animationSequence = [];
    let isSequencePlaying = false;
    let isSequencePaused = false;
    let currentSequenceIndex = 0;
    let sequenceAnimationEndListener = null;
    let progressUpdateInterval = null;
    let pausedTime = 0; // Track total paused duration
    let lastPauseStart = 0; // Track when pause started

    function initAnimationSequence(viewerId) {
      const section = document.getElementById('animation-sequence-section');
      if (!section) return;

      section.innerHTML = `
        <h4>
          動畫序列控制 (拖曳動畫到此處)
          <div class="sequence-controls">
            <button onclick="playSequence('${viewerId}')" id="play-sequence-btn">播放</button>
            <button onclick="stopSequence('${viewerId}')" class="secondary">停止</button>
            <button onclick="nextFrame('${viewerId}')" class="secondary">下一幀</button>
            <button onclick="clearSequence('${viewerId}')" class="secondary">清空</button>
          </div>
        </h4>
        <div id="sequence-drop-zone" class="empty">
          <div class="placeholder">拖曳動畫到此處建立序列</div>
        </div>
      `;

      setupSequenceDropZone(viewerId);
      renderSequence();
    }

    function setupSequenceDropZone(viewerId) {
      const dropZone = document.getElementById('sequence-drop-zone');
      if (!dropZone) return;

      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
      });

      dropZone.addEventListener('dragleave', (e) => {
        if (!dropZone.contains(e.relatedTarget)) {
          dropZone.classList.remove('drag-over');
        }
      });

      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');
        const animName = e.dataTransfer.getData('text/plain');
        if (animName) {
          addAnimationToSequence(animName);
          renderSequence();
        }
      });
    }

    function handleAnimDragStart(event, animName) {
      event.dataTransfer.setData('text/plain', animName);
      event.dataTransfer.effectAllowed = 'copy';
    }

    function addAnimationToSequence(animName) {
      animationSequence.push(animName);
      console.log('[Sequence] Added:', animName, '| Total:', animationSequence.length);
    }

    function removeAnimationFromSequence(index) {
      animationSequence.splice(index, 1);
      console.log('[Sequence] Removed at index:', index, '| Remaining:', animationSequence.length);
      renderSequence();
    }

    function clearSequence(viewerId) {
      animationSequence = [];
      currentSequenceIndex = 0;
      stopSequence(viewerId);
      renderSequence();
      console.log('[Sequence] Cleared');
    }

    function renderSequence() {
      const dropZone = document.getElementById('sequence-drop-zone');
      if (!dropZone) return;

      if (animationSequence.length === 0) {
        dropZone.classList.add('empty');
        dropZone.innerHTML = '<div class="placeholder">拖曳動畫到此處建立序列</div>';
        return;
      }

      dropZone.classList.remove('empty');
      dropZone.innerHTML = animationSequence.map((anim, index) => {
        const isPlaying = isSequencePlaying && index === currentSequenceIndex;
        const playingClass = isPlaying ? 'playing' : '';
        return `
          <div class="sequence-item ${playingClass}" draggable="true" data-index="${index}">
            <div class="sequence-item-header">
              <span class="sequence-number">${index + 1}.</span>
              <span class="drag-handle">⋮⋮</span>
              <div class="sequence-item-content">
                <span class="sequence-item-name">${anim}</span>
                <button class="remove-btn" onclick="removeAnimationFromSequence(${index})" title="移除">×</button>
              </div>
            </div>
            <div class="sequence-progress-bar">
              <div class="sequence-progress-fill" id="progress-${index}" style="width: 0%"></div>
            </div>
          </div>
        `;
      }).join('');

      // Attach drag event listeners to sequence items
      setupSequenceItemDragHandlers();
    }

    let draggedSequenceItem = null;

    function setupSequenceItemDragHandlers() {
      const items = document.querySelectorAll('.sequence-item');

      items.forEach(item => {
        item.addEventListener('dragstart', handleSequenceItemDragStart);
        item.addEventListener('dragover', handleSequenceItemDragOver);
        item.addEventListener('drop', handleSequenceItemDrop);
        item.addEventListener('dragenter', handleSequenceItemDragEnter);
        item.addEventListener('dragleave', handleSequenceItemDragLeave);
        item.addEventListener('dragend', handleSequenceItemDragEnd);
      });
    }

    function handleSequenceItemDragStart(e) {
      draggedSequenceItem = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.innerHTML);
    }

    function handleSequenceItemDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleSequenceItemDragEnter(e) {
      if (this !== draggedSequenceItem) {
        this.style.borderTop = '2px solid var(--accent)';
      }
    }

    function handleSequenceItemDragLeave(e) {
      this.style.borderTop = '';
    }

    function handleSequenceItemDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      e.preventDefault();

      if (draggedSequenceItem !== this) {
        const draggedIndex = parseInt(draggedSequenceItem.getAttribute('data-index'));
        const targetIndex = parseInt(this.getAttribute('data-index'));

        // Reorder the array
        const [removed] = animationSequence.splice(draggedIndex, 1);
        animationSequence.splice(targetIndex, 0, removed);

        console.log('[Sequence] Reordered:', animationSequence);
        renderSequence();
      }

      this.style.borderTop = '';
      return false;
    }

    function handleSequenceItemDragEnd(e) {
      this.classList.remove('dragging');

      // Clean up all border highlights
      document.querySelectorAll('.sequence-item').forEach(item => {
        item.style.borderTop = '';
      });
    }

    function playSequence(viewerId) {
      const viewer = document.getElementById(viewerId);
      const playBtn = document.getElementById('play-sequence-btn');

      // If already playing, toggle pause/resume
      if (isSequencePlaying) {
        if (!viewer || !viewer.spine || !viewer.spine.state.tracks[0]) {
          return;
        }

        const track = viewer.spine.state.tracks[0];

        if (isSequencePaused) {
          // Resume sequence
          track.timeScale = 1;
          isSequencePaused = false;

          // Add the paused duration to total paused time
          if (lastPauseStart > 0) {
            pausedTime += Date.now() - lastPauseStart;
            lastPauseStart = 0;
          }

          if (playBtn) playBtn.textContent = '暫停';
          console.log('[Sequence] Resumed');
        } else {
          // Pause sequence
          track.timeScale = 0;
          isSequencePaused = true;
          lastPauseStart = Date.now(); // Record when pause started
          if (playBtn) playBtn.textContent = '繼續';
          console.log('[Sequence] Paused');
        }
        return;
      }

      // Start new sequence playback
      if (animationSequence.length === 0) {
        alert('請先將動畫加入序列');
        return;
      }

      if (!viewer || !viewer.spine) {
        alert('無法播放序列：找不到 Spine viewer');
        return;
      }

      isSequencePlaying = true;
      isSequencePaused = false;
      currentSequenceIndex = 0;
      console.log('[Sequence] Starting playback in loop mode');

      // Update button state
      if (playBtn) playBtn.textContent = '暫停';

      playNextInSequence(viewerId);
    }

    function nextFrame(viewerId) {
      if (!isSequencePaused) return;

      const viewer = document.getElementById(viewerId);
      if (!viewer || !viewer.spine || !viewer.spine.state.tracks[0]) {
        return;
      }

      const track = viewer.spine.state.tracks[0];
      track.timeScale = 1;
      viewer.spine.state.update(1 / 60); // Advance by one frame (assuming 60fps)
      track.timeScale = 0;
    }

    function playNextInSequence(viewerId) {
      if (!isSequencePlaying || animationSequence.length === 0) return;

      const viewer = document.getElementById(viewerId);
      if (!viewer || !viewer.spine) {
        stopSequence(viewerId);
        return;
      }

      const animName = animationSequence[currentSequenceIndex];
      console.log(`[Sequence] Playing ${currentSequenceIndex + 1}/${animationSequence.length}: ${animName}`);

      // Set animation to play once (not looping)
      viewer.setAnimation(animName, false);
      renderSequence();

      // Clear previous progress interval
      if (progressUpdateInterval) {
        clearInterval(progressUpdateInterval);
        progressUpdateInterval = null;
      }

      // Reset pause tracking for new animation
      pausedTime = 0;
      lastPauseStart = 0;

      // Get animation duration and ensure animation is not paused
      const track = viewer.spine.state.tracks[0];
      if (track) {
        // Ensure animation is not paused when starting
        track.timeScale = 1;

        if (track.animation) {
          const animDuration = track.animation.duration;
          const startTime = Date.now();

          // Update progress bar periodically
          progressUpdateInterval = setInterval(() => {
            if (!isSequencePlaying) {
              clearInterval(progressUpdateInterval);
              return;
            }

            // Calculate elapsed time excluding paused duration
            let currentPausedTime = pausedTime;
            if (isSequencePaused && lastPauseStart > 0) {
              // Add current pause duration if currently paused
              currentPausedTime += Date.now() - lastPauseStart;
            }

            const elapsed = (Date.now() - startTime - currentPausedTime) / 1000; // convert to seconds
            const progress = Math.min((elapsed / animDuration) * 100, 100);

            const progressBar = document.getElementById(`progress-${currentSequenceIndex}`);
            if (progressBar) {
              progressBar.style.width = `${progress}%`;
            }

            // Stop updating when animation is complete
            if (progress >= 100) {
              clearInterval(progressUpdateInterval);
            }
          }, 16); // Update ~60fps
        }
      }      // Remove previous listener if exists
      if (sequenceAnimationEndListener) {
        viewer.spine.state.removeListener(sequenceAnimationEndListener);
      }

      // Listen for animation complete
      sequenceAnimationEndListener = {
        complete: (entry) => {
          if (!isSequencePlaying) return;

          console.log(`[Sequence] Completed: ${animName}`);

          // Clear progress interval
          if (progressUpdateInterval) {
            clearInterval(progressUpdateInterval);
            progressUpdateInterval = null;
          }

          // Reset progress bar for current animation
          const progressBar = document.getElementById(`progress-${currentSequenceIndex}`);
          if (progressBar) {
            progressBar.style.width = '0%';
          }

          // Move to next animation
          currentSequenceIndex++;

          // Loop back to start if we reached the end
          if (currentSequenceIndex >= animationSequence.length) {
            currentSequenceIndex = 0;
            console.log('[Sequence] Looping back to start');
            // Reset all progress bars when looping
            animationSequence.forEach((_, idx) => {
              const bar = document.getElementById(`progress-${idx}`);
              if (bar) bar.style.width = '0%';
            });
          }

          // Play next animation after a short delay
          setTimeout(() => {
            if (isSequencePlaying) {
              playNextInSequence(viewerId);
            }
          }, 100);
        }
      };

      viewer.spine.state.addListener(sequenceAnimationEndListener);
    }

    function stopSequence(viewerId) {
      isSequencePlaying = false;
      isSequencePaused = false;
      currentSequenceIndex = 0;
      pausedTime = 0;
      lastPauseStart = 0;

      // Clear progress update interval
      if (progressUpdateInterval) {
        clearInterval(progressUpdateInterval);
        progressUpdateInterval = null;
      }

      // Reset all progress bars
      animationSequence.forEach((_, idx) => {
        const bar = document.getElementById(`progress-${idx}`);
        if (bar) bar.style.width = '0%';
      });

      const viewer = document.getElementById(viewerId);
      if (viewer && viewer.spine && sequenceAnimationEndListener) {
        viewer.spine.state.removeListener(sequenceAnimationEndListener);
        sequenceAnimationEndListener = null;
      }

      // Update button state
      const playBtn = document.getElementById('play-sequence-btn');
      if (playBtn) playBtn.textContent = '播放';

      renderSequence();
      console.log('[Sequence] Stopped');
    }

    window.addEventListener('DOMContentLoaded', () => {
      setupSpineDragAndDrop();
      autoListSpineData('spineViewer');
      const viewer = document.getElementById('spineViewer');
      if (viewer && viewer.setHighlightColorFromCSS) {
        viewer.setHighlightColorFromCSS();
      }

      // Apply saved background color when viewer is ready
      const checkAndApplyBgColor = () => {
        if (viewer && viewer.app && viewer.app.renderer) {
          applySavedBgColor(viewer);
        } else {
          // Retry after a short delay if app not ready yet
          setTimeout(checkAndApplyBgColor, 100);
        }
      };
      checkAndApplyBgColor();
    });

    // Multi-Track Animation Functions
    let multiTrackUI = null;
    let isMultiTrackMode = false;

    async function toggleMultiTrack() {
      const viewer = document.getElementById('spineViewer');
      const button = document.getElementById('enable-multi-track-btn');
      const container = document.getElementById('multi-track-container');
      const sequenceSection = document.getElementById('animation-sequence-section');

      if (!isMultiTrackMode) {
        // Enable multi-track mode
        try {
          // Dynamically import multi-track UI module
          const { initMultiTrackUI } = await import('./src/ui/multi-track-ui.js');

          // Enable multi-track on viewer
          viewer.enableMultiTrack();

          // Initialize UI with spineViewer
          multiTrackUI = initMultiTrackUI(container, {
            maxTracks: 5,
            spineViewer: viewer
          });

          isMultiTrackMode = true;
          button.textContent = '停用多軌模式';
          button.classList.add('active');

          // Hide single-track sequence
          if (sequenceSection) {
            sequenceSection.style.display = 'none';
          }

          console.log('[Multi-Track] Enabled');
        } catch (error) {
          console.error('[Multi-Track] Failed to enable:', error);
          alert('無法啟用多軌模式：' + error.message);
        }
      } else {
        // Disable multi-track mode
        viewer.disableMultiTrack();
        container.innerHTML = '';
        multiTrackUI = null;

        isMultiTrackMode = false;
        button.textContent = '啟用多軌模式';
        button.classList.remove('active');

        // Show single-track sequence
        if (sequenceSection) {
          sequenceSection.style.display = 'block';
        }

        console.log('[Multi-Track] Disabled');
      }
    }

    // Show multi-track section after animations are loaded
    function showMultiTrackOption() {
      const multiTrackSection = document.getElementById('multi-track-section');
      if (multiTrackSection) {
        multiTrackSection.style.display = 'block';
      }
    }
  </script>
</body>

</html>